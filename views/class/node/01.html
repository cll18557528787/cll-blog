<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>【Node】- node基础模块 | Ivan Chen</title>
    <meta name="generator" content="VuePress 1.8.2">
    <link rel="icon" href="/cll-blog/favicon.ico">
    <meta name="description" content="永远充满活力的前行～">
    <meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no">
    
    <link rel="preload" href="/cll-blog/assets/css/0.styles.7c2944e4.css" as="style"><link rel="preload" href="/cll-blog/assets/js/app.b75f22a5.js" as="script"><link rel="preload" href="/cll-blog/assets/js/4.daddb1df.js" as="script"><link rel="preload" href="/cll-blog/assets/js/1.ef0066ea.js" as="script"><link rel="preload" href="/cll-blog/assets/js/24.8afa7d7b.js" as="script"><link rel="prefetch" href="/cll-blog/assets/js/10.b3a13d8b.js"><link rel="prefetch" href="/cll-blog/assets/js/11.fe07d50c.js"><link rel="prefetch" href="/cll-blog/assets/js/12.a9ff16d1.js"><link rel="prefetch" href="/cll-blog/assets/js/13.82d359c8.js"><link rel="prefetch" href="/cll-blog/assets/js/14.cfa27d08.js"><link rel="prefetch" href="/cll-blog/assets/js/15.abff44ee.js"><link rel="prefetch" href="/cll-blog/assets/js/16.62853ffe.js"><link rel="prefetch" href="/cll-blog/assets/js/17.04cb48af.js"><link rel="prefetch" href="/cll-blog/assets/js/18.7bb4c0c2.js"><link rel="prefetch" href="/cll-blog/assets/js/19.f3a32ef3.js"><link rel="prefetch" href="/cll-blog/assets/js/20.5211a042.js"><link rel="prefetch" href="/cll-blog/assets/js/21.f2b88ce9.js"><link rel="prefetch" href="/cll-blog/assets/js/22.672d632b.js"><link rel="prefetch" href="/cll-blog/assets/js/23.bcf2e811.js"><link rel="prefetch" href="/cll-blog/assets/js/25.b6007d08.js"><link rel="prefetch" href="/cll-blog/assets/js/26.7cb54d89.js"><link rel="prefetch" href="/cll-blog/assets/js/27.e7e77981.js"><link rel="prefetch" href="/cll-blog/assets/js/28.25e81466.js"><link rel="prefetch" href="/cll-blog/assets/js/29.e2f0bacb.js"><link rel="prefetch" href="/cll-blog/assets/js/30.ba397ca7.js"><link rel="prefetch" href="/cll-blog/assets/js/31.c64844aa.js"><link rel="prefetch" href="/cll-blog/assets/js/32.6d498130.js"><link rel="prefetch" href="/cll-blog/assets/js/33.7cb8ac08.js"><link rel="prefetch" href="/cll-blog/assets/js/34.63762ace.js"><link rel="prefetch" href="/cll-blog/assets/js/5.badafcf5.js"><link rel="prefetch" href="/cll-blog/assets/js/6.6143e972.js"><link rel="prefetch" href="/cll-blog/assets/js/7.d945cead.js"><link rel="prefetch" href="/cll-blog/assets/js/8.1c26169a.js"><link rel="prefetch" href="/cll-blog/assets/js/9.9f23389e.js"><link rel="prefetch" href="/cll-blog/assets/js/vendors~flowchart.570a8307.js">
    <link rel="stylesheet" href="/cll-blog/assets/css/0.styles.7c2944e4.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container no-sidebar" data-v-1156296a><div data-v-1156296a><div id="loader-wrapper" class="loading-wrapper" data-v-d48f4d20 data-v-1156296a data-v-1156296a><div class="loader-main" data-v-d48f4d20><div data-v-d48f4d20></div><div data-v-d48f4d20></div><div data-v-d48f4d20></div><div data-v-d48f4d20></div></div> <!----> <!----></div> <div class="password-shadow password-wrapper-out" style="display:none;" data-v-4e82dffc data-v-1156296a data-v-1156296a><h3 class="title" data-v-4e82dffc data-v-4e82dffc>Ivan Chen</h3> <p class="description" data-v-4e82dffc data-v-4e82dffc>永远充满活力的前行～</p> <label id="box" class="inputBox" data-v-4e82dffc data-v-4e82dffc><input type="password" value="" data-v-4e82dffc> <span data-v-4e82dffc>Konck! Knock!</span> <button data-v-4e82dffc>OK</button></label> <div class="footer" data-v-4e82dffc data-v-4e82dffc><span data-v-4e82dffc><i class="iconfont reco-theme" data-v-4e82dffc></i> <a target="blank" href="https://vuepress-theme-reco.recoluan.com" data-v-4e82dffc>vuePress-theme-reco</a></span> <span data-v-4e82dffc><i class="iconfont reco-copyright" data-v-4e82dffc></i> <a data-v-4e82dffc><span data-v-4e82dffc>陈梁梁</span>
            
          <span data-v-4e82dffc>2020 - </span>
          2021
        </a></span></div></div> <div class="hide" data-v-1156296a><header class="navbar" data-v-1156296a><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/cll-blog/" class="home-link router-link-active"><img src="/cll-blog/logo.png" alt="Ivan Chen" class="logo"> <span class="site-name">Ivan Chen</span></a> <div class="links"><div class="color-picker"><a class="color-button"><i class="iconfont reco-color"></i></a> <div class="color-picker-menu" style="display:none;"><div class="mode-options"><h4 class="title">Choose mode</h4> <ul class="color-mode-options"><li class="dark">dark</li><li class="auto active">auto</li><li class="light">light</li></ul></div></div></div> <div class="search-box"><i class="iconfont reco-search"></i> <input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/cll-blog/" class="nav-link"><i class="iconfont reco-home"></i>
  首页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-category"></i>
      分类
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/cll-blog/categories/其他/" class="nav-link"><i class="undefined"></i>
  其他
</a></li><li class="dropdown-item"><!----> <a href="/cll-blog/categories/前端/" class="nav-link"><i class="undefined"></i>
  前端
</a></li><li class="dropdown-item"><!----> <a href="/cll-blog/categories/JavaScript/" class="nav-link"><i class="undefined"></i>
  JavaScript
</a></li><li class="dropdown-item"><!----> <a href="/cll-blog/categories/node/" class="nav-link"><i class="undefined"></i>
  node
</a></li><li class="dropdown-item"><!----> <a href="/cll-blog/categories/框架/" class="nav-link"><i class="undefined"></i>
  框架
</a></li><li class="dropdown-item"><!----> <a href="/cll-blog/categories/工具/" class="nav-link"><i class="undefined"></i>
  工具
</a></li></ul></div></div><div class="nav-item"><a href="/cll-blog/tag/" class="nav-link"><i class="iconfont reco-tag"></i>
  标签
</a></div><div class="nav-item"><a href="/cll-blog/timeline/" class="nav-link"><i class="iconfont reco-date"></i>
  时间轴
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-message"></i>
      关于我
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/cll-blog/views/about/" class="nav-link"><i class="iconfont reco-account"></i>
  关于我
</a></li><li class="dropdown-item"><!----> <a href="https://github.com/cll18557528787" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="iconfont reco-github"></i>
  GitHub
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div></div> <!----></nav></div></header> <div class="sidebar-mask" data-v-1156296a></div> <aside class="sidebar" data-v-1156296a><div class="personal-info-wrapper" data-v-828910c6 data-v-1156296a><img src="/cll-blog/avatar.jpg" alt="author-avatar" class="personal-img" data-v-828910c6> <h3 class="name" data-v-828910c6>
    陈梁梁
  </h3> <div class="num" data-v-828910c6><div data-v-828910c6><h3 data-v-828910c6>23</h3> <h6 data-v-828910c6>Articles</h6></div> <div data-v-828910c6><h3 data-v-828910c6>13</h3> <h6 data-v-828910c6>Tags</h6></div></div> <ul class="social-links" data-v-828910c6></ul> <hr data-v-828910c6></div> <nav class="nav-links"><div class="nav-item"><a href="/cll-blog/" class="nav-link"><i class="iconfont reco-home"></i>
  首页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-category"></i>
      分类
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/cll-blog/categories/其他/" class="nav-link"><i class="undefined"></i>
  其他
</a></li><li class="dropdown-item"><!----> <a href="/cll-blog/categories/前端/" class="nav-link"><i class="undefined"></i>
  前端
</a></li><li class="dropdown-item"><!----> <a href="/cll-blog/categories/JavaScript/" class="nav-link"><i class="undefined"></i>
  JavaScript
</a></li><li class="dropdown-item"><!----> <a href="/cll-blog/categories/node/" class="nav-link"><i class="undefined"></i>
  node
</a></li><li class="dropdown-item"><!----> <a href="/cll-blog/categories/框架/" class="nav-link"><i class="undefined"></i>
  框架
</a></li><li class="dropdown-item"><!----> <a href="/cll-blog/categories/工具/" class="nav-link"><i class="undefined"></i>
  工具
</a></li></ul></div></div><div class="nav-item"><a href="/cll-blog/tag/" class="nav-link"><i class="iconfont reco-tag"></i>
  标签
</a></div><div class="nav-item"><a href="/cll-blog/timeline/" class="nav-link"><i class="iconfont reco-date"></i>
  时间轴
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-message"></i>
      关于我
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/cll-blog/views/about/" class="nav-link"><i class="iconfont reco-account"></i>
  关于我
</a></li><li class="dropdown-item"><!----> <a href="https://github.com/cll18557528787" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="iconfont reco-github"></i>
  GitHub
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div></div> <!----></nav> <!----> </aside> <div class="password-shadow password-wrapper-in" style="display:none;" data-v-4e82dffc data-v-1156296a><h3 class="title" data-v-4e82dffc data-v-4e82dffc>【Node】- node基础模块</h3> <!----> <label id="box" class="inputBox" data-v-4e82dffc data-v-4e82dffc><input type="password" value="" data-v-4e82dffc> <span data-v-4e82dffc>Konck! Knock!</span> <button data-v-4e82dffc>OK</button></label> <div class="footer" data-v-4e82dffc data-v-4e82dffc><span data-v-4e82dffc><i class="iconfont reco-theme" data-v-4e82dffc></i> <a target="blank" href="https://vuepress-theme-reco.recoluan.com" data-v-4e82dffc>vuePress-theme-reco</a></span> <span data-v-4e82dffc><i class="iconfont reco-copyright" data-v-4e82dffc></i> <a data-v-4e82dffc><span data-v-4e82dffc>陈梁梁</span>
            
          <span data-v-4e82dffc>2020 - </span>
          2021
        </a></span></div></div> <div data-v-1156296a><main class="page"><section><div class="page-title"><h1 class="title">【Node】- node基础模块</h1> <div data-v-1ff7123e><i class="iconfont reco-account" data-v-1ff7123e><span data-v-1ff7123e>陈梁梁</span></i> <i class="iconfont reco-date" data-v-1ff7123e><span data-v-1ff7123e>11/20/2020</span></i> <!----> <i class="tags iconfont reco-tag" data-v-1ff7123e><span class="tag-item" data-v-1ff7123e>node</span></i></div></div> <div class="theme-reco-content content__default"><blockquote><p>边学边写，冲冲冲</p></blockquote> <h2 id="了解内置模块"><a href="#了解内置模块" class="header-anchor">#</a> 了解内置模块</h2> <p>node.js的内置模块就是node本身提供的模块，不用下载，直接使用require引入就可以使用这些模块的方法了。而这些模块在浏览器环境中是不能执行的。以下与大家见面的是我们在node中常用的一些模块，如有记录不完善或者想查看更多的，请前往 http://nodejs.cn/api/ 了解更多。</p> <h2 id="path模块"><a href="#path模块" class="header-anchor">#</a> path模块</h2> <p>path用于处理文件和目录的路径。</p> <h3 id="dirname-返回当前文件所在目录的绝对路径"><a href="#dirname-返回当前文件所在目录的绝对路径" class="header-anchor">#</a> __dirname 返回当前文件所在目录的绝对路径</h3> <div class="language- line-numbers-mode"><pre class="language-text"><code>const path = require(&quot;path&quot;);
console.log(__dirname);
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><h3 id="path-join-paths-用于路径的拼接"><a href="#path-join-paths-用于路径的拼接" class="header-anchor">#</a> path.join([...paths])   用于路径的拼接</h3> <div class="language- line-numbers-mode"><pre class="language-text"><code>const path = require(&quot;path&quot;);
//路径的拼接
console.log(path.join(&quot;/node&quot;,&quot;index.json&quot;));
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h3 id="path-resolve-paths-将路径或路径片段的序列解析为绝对路径"><a href="#path-resolve-paths-将路径或路径片段的序列解析为绝对路径" class="header-anchor">#</a> path.resolve([...paths]) 将路径或路径片段的序列解析为绝对路径</h3> <div class="language- line-numbers-mode"><pre class="language-text"><code>const path = require(&quot;path&quot;);
console.log(path.resolve(&quot;.&quot;));
console.log(path.resolve(&quot;..&quot;));
console.log(path.resolve(&quot;test1&quot;,&quot;test2/test3&quot;));
//如果没有传入 path 片段，则 path.resolve() 会返回当前工作目录的绝对路径
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><h3 id="path-basename-path-ext-返回-path-的最后一部分"><a href="#path-basename-path-ext-返回-path-的最后一部分" class="header-anchor">#</a> path.basename(path[, ext]) 返回 path 的最后一部分</h3> <div class="language- line-numbers-mode"><pre class="language-text"><code>const path = require(&quot;path&quot;);
console.log(path.basename(&quot;/user/test/index.html&quot;));
console.log(path.basename(&quot;/user/test/index.html&quot;,&quot;.html&quot;));
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h2 id="fs模块"><a href="#fs模块" class="header-anchor">#</a> fs模块</h2> <p>fs用于文件或文件夹的读写操作，较常用的是以下几种：</p> <h3 id="fs-mkdir-path-options-callback-异步-新建文件夹"><a href="#fs-mkdir-path-options-callback-异步-新建文件夹" class="header-anchor">#</a> fs.mkdir(path[,options],callback)  异步 新建文件夹</h3> <div class="language- line-numbers-mode"><pre class="language-text"><code>//有三个参数，第一个参数是地址，就是你创建的文件夹存放的地址
//第二个参数不是必填的参数, options 参数可以是一个整数，用于指定文件的模式（权限与粘滞位）。 也可以是一个对象，其中 recursive 属性指定是否创建父目录。
//第三个参数是回调函数，参数就是err错误
 
fs.mkdir('/tmp/test/web', { recursive: true }, (err) =&gt; {
  if (err) throw err;
});

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><h3 id="fs-mkdirsync-path-options-同步-新建文件夹"><a href="#fs-mkdirsync-path-options-同步-新建文件夹" class="header-anchor">#</a> fs.mkdirSync(path[, options]) 同步 新建文件夹</h3> <div class="language- line-numbers-mode"><pre class="language-text"><code>//同步和异步的区别就不多说了，在写法上就是同步的方法没有回调函数
//同步调用若是出错，都会终止执行，必须用try catch来捕获错误
拿同步新建文件夹举例：
try{
    const result = mkdirSync(&quot;./test&quot;);
}catch(e){
    console.log(new Error(e));
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><h3 id="fs-rmdir-path-callback-异步-删除文件夹"><a href="#fs-rmdir-path-callback-异步-删除文件夹" class="header-anchor">#</a> fs.rmdir(path,callback) 异步 删除文件夹</h3> <div class="language- line-numbers-mode"><pre class="language-text"><code>fs.rmdir(&quot;./test&quot;,(err)=&gt;{
    console.log(err);
})
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h3 id="fs-rmdirsync-path-同步-删除文件夹"><a href="#fs-rmdirsync-path-同步-删除文件夹" class="header-anchor">#</a> fs.rmdirSync(path) 同步 删除文件夹</h3> <div class="language- line-numbers-mode"><pre class="language-text"><code>fs.rmdirSync(&quot;./test&quot;);
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h3 id="fs-readdir-path-options-callback-异步-读取文件夹"><a href="#fs-readdir-path-options-callback-异步-读取文件夹" class="header-anchor">#</a> fs.readdir(path[,options],callback) 异步 读取文件夹</h3> <div class="language- line-numbers-mode"><pre class="language-text"><code>//读取文件夹的时候，回调函数中会有两个参数，一个是错误，另一个就是读取的文件
//如果 options 是一个字符串，则指定字符编码。 如果 encoding 设为 'buffer'，则返回的文件名是 Buffer,可以定义为 utf8。
 
fs.readdir(&quot;./test&quot;,(err,files)=&gt;{
    console.log(err);
    console.log(files); // 文件夹中的文件，以数组的形式存放
})
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><h3 id="fs-readdirsync-path-options-同步-读取文件夹"><a href="#fs-readdirsync-path-options-同步-读取文件夹" class="header-anchor">#</a> fs.readdirSync(path[, options]) 同步 读取文件夹</h3> <div class="language- line-numbers-mode"><pre class="language-text"><code>//如果 options 是一个字符串，则指定字符编码。 如果 encoding 设为 'buffer'，则返回的文件名是 Buffer,可以定义为 utf8。

const a = fs.readdirSync('./');
console.log(a); // 文件夹中的文件，以数组的形式存放
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><h3 id="fs-readfile-path-options-callback-异步-读文件"><a href="#fs-readfile-path-options-callback-异步-读文件" class="header-anchor">#</a> fs.readFile(path[, options],callback); 异步 读文件</h3> <div class="language- line-numbers-mode"><pre class="language-text"><code>fs.readFile(&quot;../test/test.json&quot;,(err,data)=&gt;{
  if(err){
    console.log(err);
  }else{
    console.log(JSON.parse(data));
  }
});

//callback回调函数中有两个参数，一个是err，另一个是data，读取的数据，一般data的格式都要改变，两种方法:
1.可以写成data.toString;
2.可以调用方法的时候多加一个参数，改变数值类型的 fs.readFile(file,&quot;utf8&quot;,callback);
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><h3 id="fs-readfilesync-path-options-同步-读文件"><a href="#fs-readfilesync-path-options-同步-读文件" class="header-anchor">#</a> fs.readFileSync(path[, options]) 同步 读文件</h3> <div class="language- line-numbers-mode"><pre class="language-text"><code>const data = fs.readFileSync('../test/test.txt','utf8');
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h3 id="fs-writefile-file-data-options-callback-异步-写文件"><a href="#fs-writefile-file-data-options-callback-异步-写文件" class="header-anchor">#</a> fs.writeFile(file, data[, options], callback) 异步 写文件</h3> <div class="language- line-numbers-mode"><pre class="language-text"><code>fs.writeFile('./test/index.json',JSON.stringify(data),(err)=&gt;{
  if(err){
  	console.log(err);
  }
});
//如果没有该文件，会先创建该文件，若存在，会覆盖文件内容
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><h3 id="fs-writefilesync-file-data-options-同步-写文件"><a href="#fs-writefilesync-file-data-options-同步-写文件" class="header-anchor">#</a> fs.writeFileSync(file, data[, options]) 同步 写文件</h3> <div class="language- line-numbers-mode"><pre class="language-text"><code>try{
  fs.writeFileSync('./test/index.json',JSON.stringify(data));
}catch(err){
  console.log(err);
}

//如果没有该文件，会先创建该文件，若存在，会覆盖文件内容
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><h3 id="fs-appendfile-file-data-options-callback-异步-不覆盖写文件"><a href="#fs-appendfile-file-data-options-callback-异步-不覆盖写文件" class="header-anchor">#</a> fs.appendFile(file, data[, options], callback) 异步 不覆盖写文件</h3> <div class="language- line-numbers-mode"><pre class="language-text"><code>fs.appendFile(&quot;./file.txt&quot;,data,(err)=&gt;{
    console.log(err);
});
// 就是writeFile换成了appendFile，就可以不覆盖的写入内容了
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><h3 id="fs-appendfilesync-file-data-options-同步-不覆盖写文件"><a href="#fs-appendfilesync-file-data-options-同步-不覆盖写文件" class="header-anchor">#</a> fs.appendFileSync(file, data[, options]) 同步 不覆盖写文件</h3> <div class="language- line-numbers-mode"><pre class="language-text"><code>fs.appendFileSync(&quot;./file.txt&quot;,data);
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h3 id="fs-unlink-path-callback-异步-删除文件"><a href="#fs-unlink-path-callback-异步-删除文件" class="header-anchor">#</a> fs.unlink(path,callback) 异步 删除文件</h3> <div class="language- line-numbers-mode"><pre class="language-text"><code>fs.unlink(&quot;./file.txt&quot;,(err)=&gt;{
    console.log(err);
});
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h3 id="fs-unlinksync-path-同步-删除文件"><a href="#fs-unlinksync-path-同步-删除文件" class="header-anchor">#</a> fs.unlinkSync(path) 同步 删除文件</h3> <div class="language- line-numbers-mode"><pre class="language-text"><code>fs.unlink(&quot;./file.txt&quot;);
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h2 id="url模块"><a href="#url模块" class="header-anchor">#</a> url模块</h2> <h3 id="使用传统的-api-解析-url-字符串"><a href="#使用传统的-api-解析-url-字符串" class="header-anchor">#</a> 使用传统的 API 解析 URL 字符串</h3> <div class="language- line-numbers-mode"><pre class="language-text"><code>const url = require(&quot;url&quot;);
const myURL = url.parse('https://user:pass@sub.host.com:8080/p/a/t/h?query=string#hash');

console.log(myURL);


/* 打印结果为解析后的URL对象
Url {
  protocol: 'https:',
  slashes: true,
  auth: 'user:pass',
  host: 'sub.host.com:8080',
  port: '8080',
  hostname: 'sub.host.com',
  hash: '#hash',
  //查询字符串，这里，如果我们想要以对象形式返回，可以让url.parse的第二个参数为true
  search: '?query=string',
  query: 'query=string',
  pathname: '/p/a/t/h',
  path: '/p/a/t/h?query=string',
  href: 'https://user:pass@sub.host.com:8080/p/a/t/h?query=string#hash'
}
*/
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br></div></div><h3 id="使用-whatwg-的-api-解析-url-字符串"><a href="#使用-whatwg-的-api-解析-url-字符串" class="header-anchor">#</a> 使用 WHATWG 的 API 解析 URL 字符串</h3> <div class="language- line-numbers-mode"><pre class="language-text"><code>const {URL} = require(&quot;url&quot;);
const myURL = new URL('https://user:pass@sub.host.com:8080/p/a/t/h?query=string#hash');

console.log(myURL);

/* 打印结果为解析后的URL对象
Url {
  protocol: 'https:',
  slashes: true,
  auth: 'user:pass',
  host: 'sub.host.com:8080',
  port: '8080',
  hostname: 'sub.host.com',
  hash: '#hash',
  search: '?query=string',
  query: 'query=string',
  pathname: '/p/a/t/h',
  path: '/p/a/t/h?query=string',
  href: 'https://user:pass@sub.host.com:8080/p/a/t/h?query=string#hash'
}
*/
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br></div></div><h2 id="querystring模块"><a href="#querystring模块" class="header-anchor">#</a> querystring模块</h2> <p>queryString就是查询字符串，模块提供了一些实用函数，用于解析与格式化 URL 查询字符串</p> <h3 id="querystring-parse-str-sep-eq-options-解析url的查询字符串"><a href="#querystring-parse-str-sep-eq-options-解析url的查询字符串" class="header-anchor">#</a> querystring.parse(str[, sep[, eq[, options]]]) 解析URL的查询字符串</h3> <div class="language- line-numbers-mode"><pre class="language-text"><code>- str &lt;string&gt; 要解析的 URL 查询字符串。
- sep &lt;string&gt; 用于在查询字符串中分隔键值对的子字符串。默认值: '&amp;'。
- eq &lt;string&gt; 用于在查询字符串中分隔键和值的子字符串。默认值: '='。
- options &lt;Object&gt;:
  decodeURIComponent &lt;Function&gt; 当解码查询字符串中的百分比编码字符时使用的函数。默认  值: querystring.unescape()。  
  maxKeys &lt;number&gt; 指定要解析的键的最大数量。指定 0 可移除键的计数限制。默认值: 1000。
  
  
const qs = require('querystring');
const b = qs.parse(&quot;foo=bar&amp;abc=xyz&amp;abc=123&quot;);
console.log(b);

//{ foo: 'bar', abc: [ 'xyz', '123' ] }

//默认情况下，会假定查询字符串中的百分比编码字符使用 UTF-8 编码。 如果使用其他的字符编码，则需要指定其他的 decodeURIComponent 选项:

querystring.parse('w=%D6%D0%CE%C4&amp;foo=bar', null, null, { decodeURIComponent: gbkDecodeURIComponent });

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br></div></div><h3 id="querystring-stringify-obj-sep-eq-options-序列化字符串为url查询字符串"><a href="#querystring-stringify-obj-sep-eq-options-序列化字符串为url查询字符串" class="header-anchor">#</a> querystring.stringify(obj[, sep[, eq[, options]]]) 序列化字符串为url查询字符串</h3> <div class="language- line-numbers-mode"><pre class="language-text"><code>- obj &lt;Object&gt; 要序列化为 URL 查询字符串的对象。
- sep &lt;string&gt; 用于在查询字符串中分隔键值对的子字符串。默认值: '&amp;'。
- eq &lt;string&gt; 用于在查询字符串中分隔键和值的子字符串。默认值: '='。
- options:
encodeURIComponent &lt;Function&gt; 当将查询字符串中不安全的 URL 字符转换为百分比编码时使用的函数。默认值: querystring.escape()。

querystring.stringify({ foo: 'bar', baz: ['qux', 'quux'], corge: '' });
// 返回 'foo=bar&amp;baz=qux&amp;baz=quux&amp;corge='

querystring.stringify({ foo: 'bar', baz: 'qux' }, ';', ':');
// 返回 'foo:bar;baz:qux'

//默认情况下，查询字符串中需要进行百分比编码的字符将会被编码为 UTF-8。 如果需要其他的编码，则需要指定其他的 encodeURIComponent 选项：


querystring.stringify({ w: '中文', foo: 'bar' }, null, null, { encodeURIComponent: gbkEncodeURIComponent });
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><h2 id="events模块"><a href="#events模块" class="header-anchor">#</a> events模块</h2> <h3 id="eventemitter"><a href="#eventemitter" class="header-anchor">#</a> EventEmitter</h3> <p>events 模块提供了一个对象: events.EventEmitter</p> <p>EventEmitter 的核心就是事件触发与事件监听器功能的封装</p> <p>EventEmitter 的每个事件由一个事件名和若干个参 数组成，事件名是一个字符串，通常表达一定的语义。对于每个事件，EventEmitter 支持 若干个事件监听器。当事件触发时，注册到这个事件的事件监听器被依次调用，事件参数作 为回调函数参数传递</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>const EventEmitter = require('events'); 
class MyEmitter extends EventEmitter {}

const myEmitter = new MyEmitter();

//eventEmitter.on() 用于注册监听器， eventEmitter.emit() 用于触发事件
myEmitter.on('eventName', () =&gt; {
  console.log('事件被触发了');
});
myEmitter.emit('eventName'); 
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><h3 id="eventemitter-emit-eventname-callback-callback中this"><a href="#eventemitter-emit-eventname-callback-callback中this" class="header-anchor">#</a> eventEmitter.emit(eventName,callback)  callback中this</h3> <p>eventEmitter.emit() 方法可以传任意数量的参数到监听器函数。 当监听器函数被调用时， this 关键词会被指向监听器所绑定的 EventEmitter 实例</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>const myEmitter = new MyEmitter();
myEmitter.on('event', function(a, b) {
  console.log(a, b, this, this === myEmitter);
  // 打印:
  //   aa bb MyEmitter {
  //     domain: null,
  //     _events: { event: [Function] },
  //     _eventsCount: 1,
  //     _maxListeners: undefined } true
});
myEmitter.emit('event', 'aa', 'bb');
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>也可以使用 ES6 的箭头函数作为监听器。但 this 关键词不会指向 EventEmitter 实例</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>const myEmitter = new MyEmitter();
myEmitter.on('event', (a, b) =&gt; {
  console.log(a, b, this);
  // 打印: aa bb {}
});
myEmitter.emit('event', 'aa', 'bb');
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><h3 id="eventemitter-once"><a href="#eventemitter-once" class="header-anchor">#</a> eventEmitter.once()</h3> <p>使用 eventEmitter.once() 可以注册最多可调用一次的监听器。 当事件被触发时，监听器会被注销</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>const myEmitter = new MyEmitter();
let m = 0;
myEmitter.once('event', () =&gt; {
  console.log(++m);
});
myEmitter.emit('event');
// 打印: 1
myEmitter.emit('event');
// 不触发
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><h3 id="emitter-removelistener-eventname-listener"><a href="#emitter-removelistener-eventname-listener" class="header-anchor">#</a> emitter.removeListener(eventName, listener)</h3> <p>emitter.removeListener(eventName, listener)  从名为 eventName 的事件的监听器数组中移除指定的 listener</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>const callback = (stream) =&gt; {
  console.log('已连接');
};
server.on('connection', callback);
// ...
server.removeListener('connection', callback);
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><h3 id="emitter-removealllisteners-eventname"><a href="#emitter-removealllisteners-eventname" class="header-anchor">#</a> emitter.removeAllListeners([eventName])</h3> <p>emitter.removeAllListeners([eventName])   移除全部的事件侦听</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>server.removeAllListeners(['connection']);
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h2 id="stream-流"><a href="#stream-流" class="header-anchor">#</a> stream（流）</h2> <p>流（stream）是 Node.js 中处理流式数据的抽象接口</p> <p>Node.js 中有四种基本的流类型：</p> <p>Writable - 可写入数据的流（例如 fs.createWriteStream()）。
Readable - 可读取数据的流（例如 fs.createReadStream()）。
Duplex - 可读又可写的流（例如 net.Socket）。
Transform - 在读写过程中可以修改或转换数据的 Duplex 流（例如 zlib.createDeflate()）。
此外，该模块还包括实用函数 stream.pipeline()、stream.finished() 和 stream.Readable.from()。</p> <p>几乎所有的 Node.js 应用都在某种程度上使用了流。 下面是一个例子，使用流实现了一个 HTTP 服务器：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>const http = require('http');

const server = http.createServer((req, res) =&gt; {
  // req 是一个 http.IncomingMessage 实例，它是可读流。
  // res 是一个 http.ServerResponse 实例，它是可写流。

  let body = '';
  // 接收数据为 utf8 字符串，
  // 如果没有设置字符编码，则会接收到 Buffer 对象。
  req.setEncoding('utf8');

  // 如果添加了监听器，则可读流会触发 'data' 事件。
  req.on('data', (chunk) =&gt; {
    body += chunk;
  });

  // 'end' 事件表明整个请求体已被接收。 
  req.on('end', () =&gt; {
    try {
      const data = JSON.parse(body);
      // 响应信息给用户。
      res.write(typeof data);
      res.end();
    } catch (er) {
      // json 解析失败。
      res.statusCode = 400;
      return res.end(`错误: ${er.message}`);
    }
  });
});

server.listen(1337);
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br></div></div><h3 id="fs-createreadstream-path-options-读取文件流"><a href="#fs-createreadstream-path-options-读取文件流" class="header-anchor">#</a> fs.createReadStream(path[, options]) 读取文件流</h3> <p>可读流的事件请具体参考 http://nodejs.cn/api/stream.html 文档</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>let fs = require(&quot;fs&quot;);
let times = 0;
let stream = fs.createReadStream('../test.txt', { start: 10, end: 99 }});
stream.on(&quot;data&quot;, chunk =&gt; {
    console.log(&quot;第&quot;+(times++)+&quot;次读取的块内容：&quot;);
});
stream.on(&quot;end&quot;, () =&gt; {
    console.log(&quot;END&quot;);
});
stream.on(&quot;error&quot;, err =&gt; {
    console.log(err);
});
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><h3 id="fs-createwritestream-path-options-写入文件流"><a href="#fs-createwritestream-path-options-写入文件流" class="header-anchor">#</a> fs.createWriteStream(path[, options]) 写入文件流</h3> <p>可写流的事件请具体参考 http://nodejs.cn/api/stream.html 文档</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>let fs = require('fs');
let stream = fs.createWriteStream('../test.txt', { encoding: 'utf8' });
stream.write(&quot;要写入的文本1&quot;);
stream.write(&quot;要写入的文本2&quot;);
// ...
//二进制
//stream.write(new Buffer(&quot;文本3&quot;, 'utf8'));
//stream.write(new Buffer(&quot;文本4&quot;, 'utf8'));
// ...
stream.end(); // 终止写入
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><h3 id="readable-pipe-writable-options-把一个readable流和一个writeable流串起来"><a href="#readable-pipe-writable-options-把一个readable流和一个writeable流串起来" class="header-anchor">#</a> readable.pipe(writable[,options]) 把一个Readable流和一个Writeable流串起来</h3> <p>两个流是可以串起来的，比如把一个Readable流和一个Writeable流串起来，此时，数据就会自动从Readable流进入Writeable流，此操作成为pipe</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>let fs = require('fs');
let rs = fs.createReadStream(&quot;A.txt&quot;);
let ws = fs.createWriteStream(&quot;B.txt&quot;);

rs.pipe(ws);
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>上述代码就可以实现A.txt中的内容写入到B.txt中，默认情况下，当Readable流中的数据读取完毕后，就会触发end事件，然后自动关闭Writeable流，我们可以通过以下设定来取消自动关闭Writeable流</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>rs.pipe(ws, { end: false });
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h2 id="http模块"><a href="#http模块" class="header-anchor">#</a> http模块</h2> <p>发起http请求</p> <h3 id="http-request-options-callback-http-request-url-options-callback"><a href="#http-request-options-callback-http-request-url-options-callback" class="header-anchor">#</a> http.request(options[, callback]) / http.request(url[, options][, callback])</h3> <p>url 可以是字符串或 URL 对象。 如果 url 是一个字符串，则会自动使用 [url.URL()] 解析它。 如果它是一个 URL 对象，则会自动转换为普通的 options 对象。</p> <p>如果同时指定了 url 和 options，则对象会被合并，其中 options 属性优先。</p> <p>可选的 callback 参数会作为单次监听器被添加到 'response' 事件。</p> <p>官方事例：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>const postData = querystring.stringify({
  'msg': '你好世界'
});

const options = {
  hostname: 'nodejs.cn',
  port: 80,
  path: '/upload',
  method: 'POST',
  headers: {
    'Content-Type': 'application/x-www-form-urlencoded',
    'Content-Length': Buffer.byteLength(postData)
  }
};

const req = http.request(options, (res) =&gt; {
  console.log(`状态码: ${res.statusCode}`);
  console.log(`响应头: ${JSON.stringify(res.headers)}`);
  res.setEncoding('utf8');
  res.on('data', (chunk) =&gt; {
    console.log(`响应主体: ${chunk}`);
  });
  res.on('end', () =&gt; {
    console.log('响应中已无数据');
  });
});

req.on('error', (e) =&gt; {
  console.error(`请求遇到问题: ${e.message}`);
});

// 将数据写入请求主体。
req.write(postData);
req.end();
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br></div></div><p>在示例中调用了 req.end()。 使用 http.request() 时，必须始终调用 req.end() 来表示请求的结束，即使没有数据被写入请求主体</p> <h3 id="http-get-options-callback-http-get-url-options-callback"><a href="#http-get-options-callback-http-get-url-options-callback" class="header-anchor">#</a> http.get(options[, callback]) / http.get(url[, options][, callback])</h3> <div class="language- line-numbers-mode"><pre class="language-text"><code>http
    .get(options, response =&gt; {
      response.setEncoding('utf8');
      let data = &quot;&quot;;
      response.on(&quot;data&quot;, (chunk) =&gt; {
        data += chunk;
      });
      response.on(&quot;end&quot;, () =&gt; {
        console.log(&quot;ok&quot;);
      });
    })
    .on(&quot;error&quot;, (err) =&gt; {
      console.log(&quot;TopicList Request Error: &quot; + err.message);
    });
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><p>options 接受与 http.request() 相同的 options，但是 method 始终被设置为 GET。 从原型继承的属性会被忽略</p> <h3 id="使用http模块搭建服务器-http-createserver-options-requestlistener"><a href="#使用http模块搭建服务器-http-createserver-options-requestlistener" class="header-anchor">#</a> 使用http模块搭建服务器 http.createServer([options][, requestListener])</h3> <p>Node.js的http模块，已经帮助我们隐藏了处理TCP连接的具体细节，使得我们可以在更高的层次上直接处理，主要是使用http模块提供的request和response对象</p> <p>request对象封装了http请求
response对象封装了http相应</p> <p>1、创建一个http服务器（假设文件在server.js）：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>const http = require('http');

const server = http.createServer((request, response) =&gt; {
    response.writeHead(200, {'Content-Type': 'text/html'});
    response.end(&quot;This is a server by Node.js&quot;);
});

server.listen(1234);
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>这样子我们就完成了一个http服务器的创建了，使用node server.js开启，然后只要访问http://localhost:1234，就会看到页面上输出：This is a server by Node.js</p> <p>2、我们可以看到http.createServer中有两个参数request和response，这两个参数，request是用来获得客户端发送的HTTP请求的（request对象中包含了许多的请求信息），而response是用来让服务器做出回应的</p> <h2 id="process"><a href="#process" class="header-anchor">#</a> process</h2> <h3 id="process-nexttick-callback-args"><a href="#process-nexttick-callback-args" class="header-anchor">#</a> process.nextTick(callback[, ...args])</h3> <p>关于process.nextTick后面我们会着重去讲解</p> <h2 id="crypto模块"><a href="#crypto模块" class="header-anchor">#</a> crypto模块</h2> <p>crypto 模块提供了加密功能，包括对 OpenSSL 的哈希、HMAC、加密、解密、签名、以及验证功能的一整套封装</p> <p>这块内容，也会单独写一篇文章来深度分析一下</p> <h2 id="util实用工具"><a href="#util实用工具" class="header-anchor">#</a> util实用工具</h2> <p>具体内容请参考 http://nodejs.cn/api/util.html</p> <p>以上这些都是平时在使用node过程中比较常用的一些内容，当然如果说的不全，也希望各位多多包涵，没写全的内容请各位看官到官网去深度挖掘和吸收哦，谢谢～</p></div></section> <footer class="page-edit"><!----> <!----></footer> <!----> <div class="comments-wrapper"><!----></div> <ul class="side-bar sub-sidebar-wrapper" style="width:12rem;" data-v-70334359><li class="level-2" data-v-70334359><a href="/cll-blog/views/class/node/01.html#了解内置模块" class="sidebar-link reco-side-了解内置模块" data-v-70334359>了解内置模块</a></li><li class="level-2" data-v-70334359><a href="/cll-blog/views/class/node/01.html#path模块" class="sidebar-link reco-side-path模块" data-v-70334359>path模块</a></li><li class="level-3" data-v-70334359><a href="/cll-blog/views/class/node/01.html#dirname-返回当前文件所在目录的绝对路径" class="sidebar-link reco-side-dirname-返回当前文件所在目录的绝对路径" data-v-70334359>__dirname 返回当前文件所在目录的绝对路径</a></li><li class="level-3" data-v-70334359><a href="/cll-blog/views/class/node/01.html#path-join-paths-用于路径的拼接" class="sidebar-link reco-side-path-join-paths-用于路径的拼接" data-v-70334359>path.join([...paths])   用于路径的拼接</a></li><li class="level-3" data-v-70334359><a href="/cll-blog/views/class/node/01.html#path-resolve-paths-将路径或路径片段的序列解析为绝对路径" class="sidebar-link reco-side-path-resolve-paths-将路径或路径片段的序列解析为绝对路径" data-v-70334359>path.resolve([...paths]) 将路径或路径片段的序列解析为绝对路径</a></li><li class="level-3" data-v-70334359><a href="/cll-blog/views/class/node/01.html#path-basename-path-ext-返回-path-的最后一部分" class="sidebar-link reco-side-path-basename-path-ext-返回-path-的最后一部分" data-v-70334359>path.basename(path[, ext]) 返回 path 的最后一部分</a></li><li class="level-2" data-v-70334359><a href="/cll-blog/views/class/node/01.html#fs模块" class="sidebar-link reco-side-fs模块" data-v-70334359>fs模块</a></li><li class="level-3" data-v-70334359><a href="/cll-blog/views/class/node/01.html#fs-mkdir-path-options-callback-异步-新建文件夹" class="sidebar-link reco-side-fs-mkdir-path-options-callback-异步-新建文件夹" data-v-70334359>fs.mkdir(path[,options],callback)  异步 新建文件夹</a></li><li class="level-3" data-v-70334359><a href="/cll-blog/views/class/node/01.html#fs-mkdirsync-path-options-同步-新建文件夹" class="sidebar-link reco-side-fs-mkdirsync-path-options-同步-新建文件夹" data-v-70334359>fs.mkdirSync(path[, options]) 同步 新建文件夹</a></li><li class="level-3" data-v-70334359><a href="/cll-blog/views/class/node/01.html#fs-rmdir-path-callback-异步-删除文件夹" class="sidebar-link reco-side-fs-rmdir-path-callback-异步-删除文件夹" data-v-70334359>fs.rmdir(path,callback) 异步 删除文件夹</a></li><li class="level-3" data-v-70334359><a href="/cll-blog/views/class/node/01.html#fs-rmdirsync-path-同步-删除文件夹" class="sidebar-link reco-side-fs-rmdirsync-path-同步-删除文件夹" data-v-70334359>fs.rmdirSync(path) 同步 删除文件夹</a></li><li class="level-3" data-v-70334359><a href="/cll-blog/views/class/node/01.html#fs-readdir-path-options-callback-异步-读取文件夹" class="sidebar-link reco-side-fs-readdir-path-options-callback-异步-读取文件夹" data-v-70334359>fs.readdir(path[,options],callback) 异步 读取文件夹</a></li><li class="level-3" data-v-70334359><a href="/cll-blog/views/class/node/01.html#fs-readdirsync-path-options-同步-读取文件夹" class="sidebar-link reco-side-fs-readdirsync-path-options-同步-读取文件夹" data-v-70334359>fs.readdirSync(path[, options]) 同步 读取文件夹</a></li><li class="level-3" data-v-70334359><a href="/cll-blog/views/class/node/01.html#fs-readfile-path-options-callback-异步-读文件" class="sidebar-link reco-side-fs-readfile-path-options-callback-异步-读文件" data-v-70334359>fs.readFile(path[, options],callback); 异步 读文件</a></li><li class="level-3" data-v-70334359><a href="/cll-blog/views/class/node/01.html#fs-readfilesync-path-options-同步-读文件" class="sidebar-link reco-side-fs-readfilesync-path-options-同步-读文件" data-v-70334359>fs.readFileSync(path[, options]) 同步 读文件</a></li><li class="level-3" data-v-70334359><a href="/cll-blog/views/class/node/01.html#fs-writefile-file-data-options-callback-异步-写文件" class="sidebar-link reco-side-fs-writefile-file-data-options-callback-异步-写文件" data-v-70334359>fs.writeFile(file, data[, options], callback) 异步 写文件</a></li><li class="level-3" data-v-70334359><a href="/cll-blog/views/class/node/01.html#fs-writefilesync-file-data-options-同步-写文件" class="sidebar-link reco-side-fs-writefilesync-file-data-options-同步-写文件" data-v-70334359>fs.writeFileSync(file, data[, options]) 同步 写文件</a></li><li class="level-3" data-v-70334359><a href="/cll-blog/views/class/node/01.html#fs-appendfile-file-data-options-callback-异步-不覆盖写文件" class="sidebar-link reco-side-fs-appendfile-file-data-options-callback-异步-不覆盖写文件" data-v-70334359>fs.appendFile(file, data[, options], callback) 异步 不覆盖写文件</a></li><li class="level-3" data-v-70334359><a href="/cll-blog/views/class/node/01.html#fs-appendfilesync-file-data-options-同步-不覆盖写文件" class="sidebar-link reco-side-fs-appendfilesync-file-data-options-同步-不覆盖写文件" data-v-70334359>fs.appendFileSync(file, data[, options]) 同步 不覆盖写文件</a></li><li class="level-3" data-v-70334359><a href="/cll-blog/views/class/node/01.html#fs-unlink-path-callback-异步-删除文件" class="sidebar-link reco-side-fs-unlink-path-callback-异步-删除文件" data-v-70334359>fs.unlink(path,callback) 异步 删除文件</a></li><li class="level-3" data-v-70334359><a href="/cll-blog/views/class/node/01.html#fs-unlinksync-path-同步-删除文件" class="sidebar-link reco-side-fs-unlinksync-path-同步-删除文件" data-v-70334359>fs.unlinkSync(path) 同步 删除文件</a></li><li class="level-2" data-v-70334359><a href="/cll-blog/views/class/node/01.html#url模块" class="sidebar-link reco-side-url模块" data-v-70334359>url模块</a></li><li class="level-3" data-v-70334359><a href="/cll-blog/views/class/node/01.html#使用传统的-api-解析-url-字符串" class="sidebar-link reco-side-使用传统的-api-解析-url-字符串" data-v-70334359>使用传统的 API 解析 URL 字符串</a></li><li class="level-3" data-v-70334359><a href="/cll-blog/views/class/node/01.html#使用-whatwg-的-api-解析-url-字符串" class="sidebar-link reco-side-使用-whatwg-的-api-解析-url-字符串" data-v-70334359>使用 WHATWG 的 API 解析 URL 字符串</a></li><li class="level-2" data-v-70334359><a href="/cll-blog/views/class/node/01.html#querystring模块" class="sidebar-link reco-side-querystring模块" data-v-70334359>querystring模块</a></li><li class="level-3" data-v-70334359><a href="/cll-blog/views/class/node/01.html#querystring-parse-str-sep-eq-options-解析url的查询字符串" class="sidebar-link reco-side-querystring-parse-str-sep-eq-options-解析url的查询字符串" data-v-70334359>querystring.parse(str[, sep[, eq[, options]]]) 解析URL的查询字符串</a></li><li class="level-3" data-v-70334359><a href="/cll-blog/views/class/node/01.html#querystring-stringify-obj-sep-eq-options-序列化字符串为url查询字符串" class="sidebar-link reco-side-querystring-stringify-obj-sep-eq-options-序列化字符串为url查询字符串" data-v-70334359>querystring.stringify(obj[, sep[, eq[, options]]]) 序列化字符串为url查询字符串</a></li><li class="level-2" data-v-70334359><a href="/cll-blog/views/class/node/01.html#events模块" class="sidebar-link reco-side-events模块" data-v-70334359>events模块</a></li><li class="level-3" data-v-70334359><a href="/cll-blog/views/class/node/01.html#eventemitter" class="sidebar-link reco-side-eventemitter" data-v-70334359>EventEmitter</a></li><li class="level-3" data-v-70334359><a href="/cll-blog/views/class/node/01.html#eventemitter-emit-eventname-callback-callback中this" class="sidebar-link reco-side-eventemitter-emit-eventname-callback-callback中this" data-v-70334359>eventEmitter.emit(eventName,callback)  callback中this</a></li><li class="level-3" data-v-70334359><a href="/cll-blog/views/class/node/01.html#eventemitter-once" class="sidebar-link reco-side-eventemitter-once" data-v-70334359>eventEmitter.once()</a></li><li class="level-3" data-v-70334359><a href="/cll-blog/views/class/node/01.html#emitter-removelistener-eventname-listener" class="sidebar-link reco-side-emitter-removelistener-eventname-listener" data-v-70334359>emitter.removeListener(eventName, listener)</a></li><li class="level-3" data-v-70334359><a href="/cll-blog/views/class/node/01.html#emitter-removealllisteners-eventname" class="sidebar-link reco-side-emitter-removealllisteners-eventname" data-v-70334359>emitter.removeAllListeners([eventName])</a></li><li class="level-2" data-v-70334359><a href="/cll-blog/views/class/node/01.html#stream-流" class="sidebar-link reco-side-stream-流" data-v-70334359>stream（流）</a></li><li class="level-3" data-v-70334359><a href="/cll-blog/views/class/node/01.html#fs-createreadstream-path-options-读取文件流" class="sidebar-link reco-side-fs-createreadstream-path-options-读取文件流" data-v-70334359>fs.createReadStream(path[, options]) 读取文件流</a></li><li class="level-3" data-v-70334359><a href="/cll-blog/views/class/node/01.html#fs-createwritestream-path-options-写入文件流" class="sidebar-link reco-side-fs-createwritestream-path-options-写入文件流" data-v-70334359>fs.createWriteStream(path[, options]) 写入文件流</a></li><li class="level-3" data-v-70334359><a href="/cll-blog/views/class/node/01.html#readable-pipe-writable-options-把一个readable流和一个writeable流串起来" class="sidebar-link reco-side-readable-pipe-writable-options-把一个readable流和一个writeable流串起来" data-v-70334359>readable.pipe(writable[,options]) 把一个Readable流和一个Writeable流串起来</a></li><li class="level-2" data-v-70334359><a href="/cll-blog/views/class/node/01.html#http模块" class="sidebar-link reco-side-http模块" data-v-70334359>http模块</a></li><li class="level-3" data-v-70334359><a href="/cll-blog/views/class/node/01.html#http-request-options-callback-http-request-url-options-callback" class="sidebar-link reco-side-http-request-options-callback-http-request-url-options-callback" data-v-70334359>http.request(options[, callback]) / http.request(url[, options][, callback])</a></li><li class="level-3" data-v-70334359><a href="/cll-blog/views/class/node/01.html#http-get-options-callback-http-get-url-options-callback" class="sidebar-link reco-side-http-get-options-callback-http-get-url-options-callback" data-v-70334359>http.get(options[, callback]) / http.get(url[, options][, callback])</a></li><li class="level-3" data-v-70334359><a href="/cll-blog/views/class/node/01.html#使用http模块搭建服务器-http-createserver-options-requestlistener" class="sidebar-link reco-side-使用http模块搭建服务器-http-createserver-options-requestlistener" data-v-70334359>使用http模块搭建服务器 http.createServer([options][, requestListener])</a></li><li class="level-2" data-v-70334359><a href="/cll-blog/views/class/node/01.html#process" class="sidebar-link reco-side-process" data-v-70334359>process</a></li><li class="level-3" data-v-70334359><a href="/cll-blog/views/class/node/01.html#process-nexttick-callback-args" class="sidebar-link reco-side-process-nexttick-callback-args" data-v-70334359>process.nextTick(callback[, ...args])</a></li><li class="level-2" data-v-70334359><a href="/cll-blog/views/class/node/01.html#crypto模块" class="sidebar-link reco-side-crypto模块" data-v-70334359>crypto模块</a></li><li class="level-2" data-v-70334359><a href="/cll-blog/views/class/node/01.html#util实用工具" class="sidebar-link reco-side-util实用工具" data-v-70334359>util实用工具</a></li></ul></main> <!----></div></div></div></div><div class="global-ui"><div class="back-to-ceiling" style="right:1rem;bottom:6rem;width:2.5rem;height:2.5rem;border-radius:.25rem;line-height:2.5rem;display:none;" data-v-c6073ba8 data-v-c6073ba8><svg t="1574745035067" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="5404" class="icon" data-v-c6073ba8><path d="M526.60727968 10.90185116a27.675 27.675 0 0 0-29.21455937 0c-131.36607665 82.28402758-218.69155461 228.01873535-218.69155402 394.07834331a462.20625001 462.20625001 0 0 0 5.36959153 69.94390903c1.00431239 6.55289093-0.34802892 13.13561351-3.76865779 18.80351572-32.63518765 54.11355614-51.75690182 118.55860487-51.7569018 187.94566865a371.06718723 371.06718723 0 0 0 11.50484808 91.98906777c6.53300375 25.50556257 41.68394495 28.14064038 52.69160883 4.22606766 17.37162448-37.73630017 42.14135425-72.50938081 72.80769204-103.21549295 2.18761121 3.04276886 4.15646224 6.24463696 6.40373557 9.22774369a1871.4375 1871.4375 0 0 0 140.04691725 5.34970492 1866.36093723 1866.36093723 0 0 0 140.04691723-5.34970492c2.24727335-2.98310674 4.21612437-6.18497483 6.3937923-9.2178004 30.66633723 30.70611158 55.4360664 65.4791928 72.80769147 103.21549355 11.00766384 23.91457269 46.15860503 21.27949489 52.69160879-4.22606768a371.15156223 371.15156223 0 0 0 11.514792-91.99901164c0-69.36717486-19.13165746-133.82216804-51.75690182-187.92578088-3.42062944-5.66790279-4.76302748-12.26056868-3.76865837-18.80351632a462.20625001 462.20625001 0 0 0 5.36959269-69.943909c-0.00994388-166.08943902-87.32547796-311.81420293-218.6915546-394.09823051zM605.93803103 357.87693858a93.93749974 93.93749974 0 1 1-187.89594924 6.1e-7 93.93749974 93.93749974 0 0 1 187.89594924-6.1e-7z" p-id="5405" data-v-c6073ba8></path><path d="M429.50777625 765.63860547C429.50777625 803.39355007 466.44236686 1000.39046097 512.00932183 1000.39046097c45.56695499 0 82.4922232-197.00623328 82.5015456-234.7518555 0-37.75494459-36.9345906-68.35043303-82.4922232-68.34111062-45.57627738-0.00932239-82.52019037 30.59548842-82.51086798 68.34111062z" p-id="5406" data-v-c6073ba8></path></svg></div></div></div>
    <script src="/cll-blog/assets/js/app.b75f22a5.js" defer></script><script src="/cll-blog/assets/js/4.daddb1df.js" defer></script><script src="/cll-blog/assets/js/1.ef0066ea.js" defer></script><script src="/cll-blog/assets/js/24.8afa7d7b.js" defer></script>
  </body>
</html>
