(window.webpackJsonp=window.webpackJsonp||[]).push([[23],{610:function(s,n,a){"use strict";a.r(n);var t=a(4),e=Object(t.a)({},(function(){var s=this,n=s.$createElement,a=s._self._c||n;return a("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[a("blockquote",[a("p",[s._v("夯实基础，方能手到擒来")])]),s._v(" "),a("h2",{attrs:{id:"闭包概念"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#闭包概念"}},[s._v("#")]),s._v(" 闭包概念")]),s._v(" "),a("p",[s._v("简单讲，闭包就是指有权访问另一个函数作用域中变量的函数。个人认为，理解闭包的关键在于：外部函数调用之后其变量本应该被销毁，但闭包的存在使我们仍然可以访问外部函数的变量，这就是闭包的重要概念。")]),s._v(" "),a("p",[s._v("那为什么是说：有权访问另一个函数作用域中的变量呢，难道函数的作用域不是谁都可以访问的吗？答案确实是不是谁都有权访问的。在JS中, 全局变量有全局作用域,函数内声明的变量有局部作用域，局部作用域之间是无法互通的，JS在运行每个函数时,都会为该函数创建执行环境，即所说的作用域,在这个环境中，只有该作用域中的函数有权访问该作用域中的变量，因此，有权访问另一个函数作用域中变量的函数肯定是函数中嵌套着函数这种情况下了。")]),s._v(" "),a("h2",{attrs:{id:"闭包现象"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#闭包现象"}},[s._v("#")]),s._v(" 闭包现象")]),s._v(" "),a("p",[s._v("正常情况下，当函数执行完后，JS会销毁当前函数执行环境和调用对象,等待垃圾回收机制将函数中用过且没有后续引用的变量回收，但如果出现以下情况：")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("let fn = ()=>{\n\tlet a = 0;\n    return ()=>{\n    \tconsole.log(a + 1);\n    }\n};\nlet bar = fn();\nbar();\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br")])]),a("p",[s._v("现在出现了嵌套函数,fn函数执行后其作用域被销毁，但返回的函数内部依赖着fn作用域中的变量a，bar函数的执行需要该变量，因此该变量不会被销毁，仍保存在内存中，这种现象就是闭包现象。")]),s._v(" "),a("h2",{attrs:{id:"闭包的应用"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#闭包的应用"}},[s._v("#")]),s._v(" 闭包的应用")]),s._v(" "),a("ul",[a("li",[s._v("for循环中\n我们来看一下下面这种情况：")])]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("for(var i=0;i<5;i++){\n  setTimeout(()=>{\n    console.log(i);\n  },1000)\n}\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br")])]),a("p",[s._v("上述代码执行后可以发现，若不用let来定义i，打印出的都是5 5 5 5 5，这是因为var是全局变量，setTimeout是宏任务，所以在执行定时器的时候，for循环已经执行结束，所以打印出的都是5。那么其实用闭包可以解决这个问题：")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("for(var i=0;i<5;i++){\n  (function(i){\n    setTimeout(()=>{\n      console.log(i);\n    },1000)\n  })(i);\n}\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br")])]),a("p",[s._v("执行上述代码后可以发现，打印出的是0 1 2 3 4；说明闭包可以解决这个问题")]),s._v(" "),a("ul",[a("li",[s._v("单例模式\n请看下面代码：")])]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("let singleton = (function(){\n\tlet age = 18;\n    let speak = ()=>{\n    \tconsole.log('speaking');\n    };\n    return {\n      name: 'liang',\n      getAge: ()=>{\n        return age;\n      }\n    }\n})()\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br"),a("span",{staticClass:"line-number"},[s._v("10")]),a("br"),a("span",{staticClass:"line-number"},[s._v("11")]),a("br"),a("span",{staticClass:"line-number"},[s._v("12")]),a("br")])]),a("p",[s._v("上述代码就创建了一个单例,匿名函数最大的用途就是创建闭包，并且可以构建命名空间，用来减少全局变量，使闭包模块话代码，减少变量的污染，尤其是一个项目中多人协同开发的场景中，很多框架中都会利用匿名函数自执行方法。")]),s._v(" "),a("ul",[a("li",[s._v("柯里化")])]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("function curry(fn) {\n     let arg=[];\n     return function () {\n         if(arguments.length===0){\n             fn.apply(null,arg);\n         }else{\n             let arr=Array.from(arguments);\n             arg=arg.concat(arr);\n         }\n     }\n }\n function getSum() {\n     let arr=Array.from(arguments);\n     let sum=arr.reduce(function (sum,item) {\n         return sum+item;\n     });\n     console.log(sum);\n }\nlet fn=curry(getSum);\n fn(10);\n fn(20);\n fn(30);\n fn();\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br"),a("span",{staticClass:"line-number"},[s._v("10")]),a("br"),a("span",{staticClass:"line-number"},[s._v("11")]),a("br"),a("span",{staticClass:"line-number"},[s._v("12")]),a("br"),a("span",{staticClass:"line-number"},[s._v("13")]),a("br"),a("span",{staticClass:"line-number"},[s._v("14")]),a("br"),a("span",{staticClass:"line-number"},[s._v("15")]),a("br"),a("span",{staticClass:"line-number"},[s._v("16")]),a("br"),a("span",{staticClass:"line-number"},[s._v("17")]),a("br"),a("span",{staticClass:"line-number"},[s._v("18")]),a("br"),a("span",{staticClass:"line-number"},[s._v("19")]),a("br"),a("span",{staticClass:"line-number"},[s._v("20")]),a("br"),a("span",{staticClass:"line-number"},[s._v("21")]),a("br"),a("span",{staticClass:"line-number"},[s._v("22")]),a("br"),a("span",{staticClass:"line-number"},[s._v("23")]),a("br")])]),a("p",[s._v("上述案例，运行一个函数，如果传参，将参数存储，如果不传参，将存储的参数累加并打印。柯里化函数利用了闭包的特点，传入的参数会做存储留用，等到参数传完了，再对参数做处理")]),s._v(" "),a("h2",{attrs:{id:"闭包的优点"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#闭包的优点"}},[s._v("#")]),s._v(" 闭包的优点")]),s._v(" "),a("ul",[a("li",[s._v("闭包可以使函数的作用域延长,以至于可以在外部访问到函数内部的变量")]),s._v(" "),a("li",[s._v("闭包可以维持一个变量一直在内存中,不会被垃圾回收机制回收")]),s._v(" "),a("li",[s._v("闭包可以用来减少全局变量的污染")])]),s._v(" "),a("h2",{attrs:{id:"闭包的缺点"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#闭包的缺点"}},[s._v("#")]),s._v(" 闭包的缺点")]),s._v(" "),a("ul",[a("li",[s._v("使用闭包不当，会导致内存泄露")]),s._v(" "),a("li",[s._v("内存消耗很大，所以不能滥用闭包")]),s._v(" "),a("li",[s._v("我们使用闭包之后,要清除这个闭包")])]),s._v(" "),a("h2",{attrs:{id:"闭包的this指向"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#闭包的this指向"}},[s._v("#")]),s._v(" 闭包的this指向")]),s._v(" "),a("p",[s._v("我们先来看一下代码:")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("function fn(){\n\treturn function(){\n    \tconsole.log(this);\n    }\n}\nfn()();\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br")])]),a("p",[s._v("执行上述代码，可以发现，打印出的是window对象，可见闭包中的内部函数this指向的是window")]),s._v(" "),a("h2",{attrs:{id:"结束语"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#结束语"}},[s._v("#")]),s._v(" 结束语")]),s._v(" "),a("p",[s._v("好啦，那么关于闭包的知识我们就先记录到这啦，闭包在实际开发过程中如何使用，还是需要结合场景来的，运用合理会大大提高业务能力，但倘若运用不当，也会对性能造成很严重的消耗哦，请谨慎哦～")])])}),[],!1,null,null,null);n.default=e.exports}}]);